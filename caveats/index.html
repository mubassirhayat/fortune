<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><html lang="en"><head><title>Caveats</title><meta name="viewport" content="width=device-width,initial-scale=1"><meta charset="utf-8"><link rel="icon" href="../assets/piggu.png"><link rel="stylesheet" href="../assets/index.css"></head><body><header><a href="https://github.com/fortunejs/fortune" id="corner">Fork on GitHub</a> <a href="../"><img src="../assets/piggu.svg" alt="Piggu" class="emblem"></a> <a href="../"><img src="../assets/fortune_type.svg" alt="Fortune.js" class="logo-type"></a><nav><a href="../getting-started/">Getting Started</a><!--
        --><a href="../api/">API Reference</a><!--
        --><a href="../plugins/">Plugins</a></nav></header><article><h1>Caveats</h1><p>Using Fortune comes with some tradeoffs that arise from intentional design decisions. The adapters and serializers are designed to be standalone classes that implement a basic set of contracts. This makes the system flexible enough to be backed by anything from a text file to a distributed database, or doing I/O with a variety of formats, and this comes with trade-offs.</p><h3 id="what-it-is-not">What It Is Not<a class="anchor" href="#what-it-is-not" title="Link to this section “What It Is Not”">#</a></h3><p>Fortune is not a framework, it is intended to be composed within Node web frameworks or used as a standalone library. There are not features that web frameworks typically provide, such as application structure, active records, route matching (this may optionally be handled by the serializer), etc.</p><h3 id="undirected-graph">Undirected Graph<a class="anchor" href="#undirected-graph" title="Link to this section “Undirected Graph”">#</a></h3><p>Fortune denormalizes all relationships by their inverse fields. If you do not specify an inverse field for a link explicitly, Fortune will automatically create one that is named like <code>__${type}_${field}_inverse</code> (this field should never be exposed). There are a few reasons:</p><ul><li>An undirected graph makes it impossible to reach an orphan node without <em>a priori</em> knowledge. See <a href="http://xanadu.com/xuTheModel/">deep hypertext in Xanadu</a> for the concept behind this.</li><li>Showing relationships is more performant since there is less querying to be done (the data is denormalized), but writing relationships is slower depending on the amount of related records.</li></ul><p>This is a tradeoff that sacrifices flexibility in favor of visibility. The design also eliminates guarantees of consistency in databases that do not support transactions.</p><h3 id="polymorphic-associations">Polymorphic Associations<a class="anchor" href="#polymorphic-associations" title="Link to this section “Polymorphic Associations”">#</a></h3><p>This is not supported and will not be. Just create multiple foreign keys to support linking to different types.</p><h3 id="key-value-storage">Key-Value Storage<a class="anchor" href="#key-value-storage" title="Link to this section “Key-Value Storage”">#</a></h3><p>There is no built-in support for deeply nested objects, it treats an object as a singular value. Any comprehension of data types beyond the built-ins is specific to the adapter.</p></article><footer><p>&copy; 2015 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></p></footer></body></html>