<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><html lang="en"><head><title>Getting Started</title><meta name="viewport" content="width=device-width,initial-scale=1"><meta charset="utf-8"><link rel="icon" href="../assets/piggu.png"><link rel="stylesheet" href="../assets/index.css"></head><body><header><a href="https://github.com/fortunejs/fortune" id="corner"><span>Fork on</span> GitHub</a> <a href="../"><img src="../assets/piggu.svg" alt="Piggu" class="emblem"></a> <a href="../"><img src="../assets/fortune_type.svg" alt="Fortune.js" class="logo-type"></a><nav><a href="../getting-started/">Getting Started</a><!--
        --><a href="../api/">API Reference</a><!--
        --><a href="../plugins/">Plugins</a></nav></header><article><h1>Getting Started</h1><p>Fortune provides generic features (mostly <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> and <a href="https://en.wikipedia.org/wiki/Serialization">serialization</a>) intended to be used in web applications, or <a href="https://www.reddit.com/r/programming/comments/1a2mf7/programming_is_terriblelessons_learned_from_a/c8tjzl5"><em>skins around databases</em></a> for the haters. The purpose is to provide data persistence and manipulation given a set of record types that conform to <a href="http://fortunejs.com/api/#fortune-definetype">some limitations</a>.</p><p>The first thing you&#39;ll have to do is install <a href="https://nodejs.org/">Node.js</a> (if you&#39;re on Linux, install <code>nodejs</code> from your package manager). Optionally, you will need <a href="http://babeljs.io">Babel</a> to run ES6 code:</p><pre><code class="lang-sh">$ npm <span class="hljs-operator"><span class="hljs-keyword">install</span> -<span class="hljs-keyword">g</span> babel</span>
</code></pre><p><em>Note: if the above did not work, you probably don&#39;t have permissions, <a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions">here are workarounds</a>.</em></p><p>Then install Fortune from the command-line:</p><pre><code class="lang-sh">$ npm <span class="hljs-keyword">install</span> fortune
</code></pre><p>Then create an empty <code>index.js</code> file next to the <code>node_modules</code> folder, and start by importing Fortune and creating an instance:</p><pre><code class="lang-js"><span class="hljs-keyword">import</span> fortune <span class="hljs-keyword">from</span> <span class="hljs-string">'fortune'</span>
<span class="hljs-keyword">const</span> store = fortune.create()
</code></pre><p>We don&#39;t need to pass any arguments to the constructor for now, the defaults should work.</p><h2 id="linking">Linking<a class="anchor" href="#linking" title="Link to this section “Linking”">#</a></h2><p>The instance must have record types to be useful. Let&#39;s start with a basic example:</p><pre><code class="lang-js">store.defineType(<span class="hljs-string">'user'</span>, {
<span class="hljs-label">  username:</span> { <span class="hljs-string">type:</span> String },
<span class="hljs-label">  key:</span> { <span class="hljs-string">type:</span> Buffer },
<span class="hljs-label">  salt:</span> { <span class="hljs-string">type:</span> Buffer },
<span class="hljs-label">  group:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'group'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'users'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> }
})

store.defineType(<span class="hljs-string">'group'</span>, {
<span class="hljs-label">  name:</span> { <span class="hljs-string">type:</span> String },
<span class="hljs-label">  users:</span> { <span class="hljs-string">link:</span> <span class="hljs-string">'user'</span>, <span class="hljs-string">inverse:</span> <span class="hljs-string">'group'</span>, <span class="hljs-string">isArray:</span> <span class="hljs-literal">true</span> }
})
</code></pre><p>This defines a <code>user</code> record type that has a relationship to the <code>group</code> type. By default, relationships are to-one, unless <code>isArray</code> is specified. In this example, there is a many-to-many relationship between a user and a group. The <code>inverse</code> field specifies a corresponding field on the linked type, so that any update to either field will affect the other.</p><h2 id="transformation">Transformation<a class="anchor" href="#transformation" title="Link to this section “Transformation”">#</a></h2><p>Transformations can be defined per record type. Transform functions accept at least two arguments, the <code>context</code> object, the record, and optionally the <code>update</code> object for an <code>update</code> request. The method of an input transform may be any method except <code>find</code>, and an output transform may be applied to all methods.</p><p>Here are some implementation details for dealing with passwords:</p><pre><code class="lang-js"><span class="hljs-built_in">import</span> crypto from 'crypto'

const [ iterations, keyLength, saltLength ] =
  [ Math.<span class="hljs-built_in">pow</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">15</span>)</span>, Math.<span class="hljs-built_in">pow</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>)</span>, Math.<span class="hljs-built_in">pow</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)</span> ]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">passwordCheck</span> <span class="hljs-params">(password, key, salt)</span> {</span>
  return new Promise<span class="hljs-params">(<span class="hljs-params">(resolve, reject)</span> =&gt; crypto.pbkdf2<span class="hljs-params">(
    password, salt, iterations, keyLength, <span class="hljs-params">(error, buffer)</span> =&gt;
      error ? reject<span class="hljs-params">(error)</span> : key.equals<span class="hljs-params">(buffer)</span> ? resolve<span class="hljs-params">()</span> : reject<span class="hljs-params">()</span>)</span>)</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateSalt</span> <span class="hljs-params">()</span> {</span>
  return new Promise<span class="hljs-params">(<span class="hljs-params">(resolve, reject)</span> =&gt;
    crypto.randomBytes<span class="hljs-params">(saltLength, <span class="hljs-params">(error, buffer)</span> =&gt;
    error ? reject<span class="hljs-params">(error)</span> : resolve<span class="hljs-params">(buffer)</span>)</span>)</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateKey</span> <span class="hljs-params">(password, salt)</span> {</span>
  return new Promise<span class="hljs-params">(<span class="hljs-params">(resolve, reject)</span> =&gt;
    crypto.pbkdf2<span class="hljs-params">(password, salt, iterations, keyLength, <span class="hljs-params">(error, buffer)</span> =&gt;
      error ? reject<span class="hljs-params">(error)</span> : resolve<span class="hljs-params">(buffer)</span>)</span>)</span>
}
</code></pre><p>This is a pretty basic implementation using the <code>crypto</code> module provided by Node.js to check and generate passwords. For the user type, it would be a good idea to store the password as a cryptographically secure key, and to hide sensitive fields when displaying the record.</p><pre><code class="lang-js">const { methods, errors } = fortune

store.transformInput('user', (context, record, <span class="hljs-operator"><span class="hljs-keyword">update</span>) =&gt; {
  const { request: { method, <span class="hljs-keyword">type</span>, meta } } = <span class="hljs-keyword">context</span>
  let { <span class="hljs-keyword">key</span>, <span class="hljs-keyword">salt</span>, <span class="hljs-keyword">password</span> } = <span class="hljs-built_in">record</span>

  <span class="hljs-keyword">if</span> (method === methods.<span class="hljs-keyword">create</span> &amp;&amp; !<span class="hljs-keyword">password</span>)
    throw <span class="hljs-keyword">new</span> <span class="hljs-keyword">errors</span>.BadRequestError(<span class="hljs-string">`Password must be specified.`</span>)

  <span class="hljs-keyword">return</span> method !== methods.<span class="hljs-keyword">create</span> ? passwordCheck(
    <span class="hljs-keyword">new</span> Buffer(meta[<span class="hljs-string">'authorization'</span>] || <span class="hljs-string">''</span>, <span class="hljs-string">'base64'</span>).toString(),
    <span class="hljs-keyword">key</span>, <span class="hljs-keyword">salt</span>.toString()) : Promise.resolve()

  .catch(() =&gt; {
    throw <span class="hljs-keyword">new</span> <span class="hljs-keyword">errors</span>.UnauthorizedError(<span class="hljs-string">`Incorrect password.`</span>)
  })

  .<span class="hljs-keyword">then</span>(() =&gt; {
    <span class="hljs-keyword">if</span> (method === methods.<span class="hljs-keyword">delete</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">password</span>) <span class="hljs-keyword">password</span> = <span class="hljs-keyword">update</span>.<span class="hljs-keyword">replace</span>.<span class="hljs-keyword">password</span>

    <span class="hljs-keyword">return</span> generateSalt()
    .<span class="hljs-keyword">then</span>(buffer =&gt; {
      <span class="hljs-keyword">salt</span> = buffer
      <span class="hljs-keyword">return</span> generateKey(<span class="hljs-keyword">password</span>, <span class="hljs-keyword">salt</span>.toString())
    })
    .<span class="hljs-keyword">then</span>(buffer =&gt; {
      <span class="hljs-keyword">key</span> = buffer
      <span class="hljs-keyword">if</span> (method === methods.<span class="hljs-keyword">create</span>) {
        <span class="hljs-built_in">record</span>.<span class="hljs-keyword">key</span> = <span class="hljs-keyword">key</span>
        <span class="hljs-built_in">record</span>.<span class="hljs-keyword">salt</span> = <span class="hljs-keyword">salt</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">record</span>
      }
      <span class="hljs-keyword">update</span>.<span class="hljs-keyword">replace</span> = { <span class="hljs-keyword">key</span>, <span class="hljs-keyword">salt</span> }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">update</span>
    })
  })
})</span>
</code></pre><p>Input transform functions are run before anything gets persisted, so it is safe to throw errors. They may either synchronously return a value, or return a Promise. Note that the <code>password</code> field on the record is not defined in the record type, arbitrary fields are not persisted. Updating the password in this example requires a field in the <code>meta</code> object, for example <code>Authorization: &quot;Zm9vYmFyYmF6cXV4&quot;</code> where the value is the base64 encoded old password.</p><p>It may be required to transform outputs as well. In this example, we don&#39;t want expose the salt and the key publicly:</p><pre><code class="lang-js">store.transformOutput(<span class="hljs-string">'user'</span>, <span class="hljs-function"><span class="hljs-params">(context, record)</span> =&gt;</span> {
  <span class="hljs-regexp">//</span> Hide sensitive fields.
  <span class="hljs-keyword">delete</span> record.salt
  <span class="hljs-keyword">delete</span> record.key
  <span class="hljs-keyword">return</span> record
})
</code></pre><p>The output transform has the same arguments as the input transform, but is applied on all requests. Some serializers may not show the resolved value of the output transform for certain requests, such as updating and deleting. It must return the record, either synchronously or as a promise.</p><h2 id="finishing">Finishing<a class="anchor" href="#finishing" title="Link to this section “Finishing”">#</a></h2><p>To start the application, we need to call the <code>connect</code> method.</p><pre><code class="lang-js"><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">'http'</span>

<span class="hljs-keyword">const</span> listener = fortune.net.http(store)
<span class="hljs-keyword">const</span> server = http.createServer(listener)
<span class="hljs-keyword">const</span> port = <span class="hljs-number">1337</span>

store.connect().<span class="hljs-keyword">then</span>(() =&gt; {
  server.listen(port)
  <span class="hljs-built_in">console</span>.log(`Server <span class="hljs-keyword">is</span> listening <span class="hljs-literal">on</span> port ${port}...`)
})
</code></pre><p>Using Fortune with HTTP is optional, but since the built-in serializers provide HTTP functionality in conjunction with the <code>fortune.net.http</code> module, it&#39;s easy to get started with it. The <code>fortune.net.http</code> module returns a listener function that accepts a <code>request</code> and <code>response</code> object that is generated by Node.js.</p><p>Starting the application:</p><pre><code class="lang-sh">$ <span class="hljs-keyword">babel-node </span>.
</code></pre><p>Making a cURL request to the server:</p><pre><code class="lang-sh">$ curl -X GET -H <span class="hljs-string">"Accept: application/json"</span> -v <span class="hljs-string">http:</span><span class="hljs-comment">//localhost:1337</span>
</code></pre><p>The response should be an enumeration of types. Subsequent requests are templated: <code>/:type/:ids</code>. IDs may be comma separated.</p></article><footer><p>&copy; 2015 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></p></footer></body></html>